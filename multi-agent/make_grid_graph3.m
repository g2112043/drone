function [W] = make_grid_graph3(nx,ny,meas,build,maxv)
% Make a graph for nx-ny grid with weight generated by gen
% gen(x,y) generates weight at (x,y)
%   high value means high possibility to burn
%   gen must work with matrix arguments,that is x or y possible to choose as
%   a matrix.
% maxv : max probability, 300m尺度で0.04が目安
% meas : map scale, mease=1なら1セル1m
% E : edge matrix : N-N size matrix where N = nx*ny
% eij : (i,j) element of E
% eij > 0 if edge exists from j to i else eij = 0
% W : weight matrix : nx-ny size matrix
arguments
    nx
    ny
    meas
    build
    maxv = 1
end
N = nx*ny;
mapsize = 3/meas;   %尺度計算に使う
mapdiameter = meas * 100;   %mainのmaptrueと同じ
%% 自動生成マップ (84-202まで)
% shaperead Ver マップの読み込み
% S = shaperead('20160401-建築物の外周線.shp');
% S = shaperead('building_15216.dbf');

format long
if build == 1
    addpath('C:\Users\tobit\OneDrive - 東京都市大学 Tokyo City University\高機能研2023\修士研究_2023\プログラム_2023(継続)\基本プログラム\multi-agent\shape_share20221014')
    S = shaperead('building_13112.shp');
    % wooden_flaが1で木造、0で非木造と判定
    xx = []; yy = []; mapnum = 1; woodnum = 1;
    % 非木造のみのマップ
    for i = 1:length(S)
        if S(i).wooden_fla == 0
            xx = cat(2,xx,[S(i).X]);
            yy = cat(2,yy,[S(i).Y]);
            mapnum = mapnum + 1;
        else
            woodnum = woodnum + 1;
        end
    end
    xxm = min(xx);
    yym = min(yy);
elseif build == 0
    addpath('C:\Users\tobit\OneDrive - 東京都市大学 Tokyo City University\高機能研2023\修士研究_2023\プログラム_2023(継続)\分析\周作\20160401')
    S = shaperead('20160401-建築物の外周線.shp');
else
    disp("buildの設定が不適切です")
end

% 建築物全てのマップ
x = [S.X];
y = [S.Y];
xm = min(x);
ym = min(y);
format long


% 改良部分 探索項
% 建物誤認識の解決策
% 同一値を探索し合体する
% [1 2 3 NaN],[3 4 NaN] => [1 2 3 4 NaN]
% ここではデータ群の頭としっぽが繋がるデータを探査
clear a b zero
zero = 0;
for i = 1:length(S)
    lenSiX = length(S(i).X);
    deld = 0;
    for j = 1:lenSiX-1
        if length(find(S(i).X(j) == x)) >= 2 && S(i).X(1) ~= S(i).X(lenSiX-1)
            %x中に同じデータが2つある && 同一データ群S(n).X内ではない
            %上記の条件を満たす=データの統合が必要なデータ群
            deld = deld + 1;
            if deld >= 2    %Map範囲縁の建物の削除（不完全）
                zero = zero + 1;
                a(zero) = i;    %(1,...,NaN)が他と結合できるするデータ群ナンバーS(i).Xで参照可能
                b(zero) = j;    %接続先の最終項（[a b ... z NaN]のz）
            end
        end
    end
end
point = zero;  %fusion pointがいくつあるか

if  point ~= 0
    % 改良部分 合体項
    % ここでは探査結果a,bを用いてデータ群を結合
    % このとき余ったほうは[0 NaN]にひとまず置換
    for i = 1:length(a)
        for j = 1:length(b)
            if S(a(i)).X(end-1) == S(a(j)).X(1) && i ~= j
                A = S(a(i)).X;
                A(:,end-1:end) = [];
                S(a(j)).X = [A S(a(j)).X];  %x成分のデータ接続
                B = S(a(i)).Y;
                B(:,end-1:end) = [];
                S(a(j)).Y = [B S(a(j)).Y];  %y成分のデータ接続
                S(a(i)).X = zeros(1,2); %ここから下で重複する部分を[0 NaN]に置換
                S(a(i)).Y = zeros(1,2);
                S(a(i)).X(1) = xm;   % 後で引いた時に0になるように0ではなくxmに
                S(a(i)).Y(1) = ym; 
                S(a(i)).X(end) =NaN;
                S(a(i)).Y(end) =NaN;
            end
        end
    end
    
    % 改良部分 削除項
    % S(n).X = [0 NaN]の部分を削除
    nan = 0;    %Sの中で消されたデータの数
    for i = 1:length(a)
        if S(a(i)).X(1) == xm && length(S(a(i)).X) == 2
            S(a(i)).X = [];
            S(a(i)).Y = [];
            nan = nan + 1;
        end
    end

else
    disp("破損したGISデータは存在しませんでした")
end

% 建物のラベリング
label = zeros(length(S),3);
for i = 1:length(S)
    if ~isempty(S(i).X) %意味：length(S(i).X) ~= 0
        labelseed = S(i).X;
        lablend = length(labelseed);
        labelseed(lablend) = [];
        labelseed(lablend-1) = [];
        label(i,1) = mean(labelseed);

        labelseed = S(i).Y;
        labelseed(lablend) = [];
        labelseed(lablend-1) = [];
        label(i,2) = mean(labelseed);
    elseif isempty(S(i).X)
        label(i,1) = xm;
        label(i,2) = ym;
    end
    label(i,3) = i;
end

% 範囲調整したマップの出力項
if xm>0
    x = x - abs(xm);
else
    x = x + abs(xm);
end
if ym>0
    y = y - abs(ym);
else
    y = y + abs(ym);
end
if build == 1
    if xxm>0
        xx = xx - abs(xxm);
    else
        xx = xx + abs(xxm);
    end
    if yym>0
        yy = yy - abs(yym);
    else
        yy = yy + abs(yym);
    end
end

% 行列生成 範囲絞り機能付きVer
% NaNは区切りを意味する。値が入ってない
if build == 1
    % 経度(横・x軸方向) 1㎞ = 0.010966404715491394度
    % 緯度(縦・y軸方向) 1㎞ = 0.0090133729745762度
    x = (1000 * x)/0.011;   % 経度のm変換
    y = (1000 * y)/0.0099;  % 緯度のm変換
    xx = (1000 * xx)/0.011;   % 経度のm変換
    yy = (1000 * yy)/0.0099;  % 緯度のm変換
    scal = 500 - mapdiameter;

    xslide = 6000 + scal;      %世田谷全体(by秋山データ)
    yslide = 500 + scal;       %世田谷全体(by秋山データ)
    if xslide + mapdiameter > max(x) || yslide + mapdiameter > max(y)
        disp("slide量またはnxが大きすぎます");
    end
elseif build == 0
    xslide = 700;   %700
    yslide = 235;   %150
    if xslide + nx > max(x) || yslide + ny > max(y)
        disp("slide量またはnxが大きすぎます");
    end
else
    disp("buildの設定が不適切です")
end
disp("マップのベクトル化が完了しました");

[xq,yq] = meshgrid(1:meas:nx*meas);
xq = xq + xslide;
yq = yq + yslide;
in = inpolygon(xq,yq,x,y);
in = logical(in);
in2 = 0;
if build == 1
    in2 = inpolygon(xq,yq,xx,yy);
    in2 = logical(in2);
end
A = in - (in2*3)/4;
W = A;
disp("マップの重み行列化が完了しました");


W = sparse(A);    %スパース化による軽量化

%% 
maxW = max(W,[],'all');
if maxW > 1 | maxv~=1
    W = (maxv*W/maxW);
end
end

