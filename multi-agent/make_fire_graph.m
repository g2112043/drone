function [E,ES,EF,E2] = make_fire_graph(nx,ny,meas,build,W,wind1,wind2,mapd,maxv)
% Make a graph for nx-ny grid with weight generated by gen
% gen(x,y) generates weight at (x,y)
%   high value means high possibility to burn
%   gen must work with matrix arguments,that is x or y possible to choose as
%   a matrix.
% maxv : max probability, 300m尺度で0.04が目安
% meas : map scale, mease=1なら1セル1m
% E : edge matrix : N-N size matrix where N = nx*ny
% eij : (i,j) element of E
% eij > 0 if edge exists from j to i else eij = 0
% W : weight matrix : nx-ny size matrix
% wind1 : 風向(32方位) , wind2 : 風速
% build : モデルのタイプ　3，延焼速度調整モード
arguments
    nx
    ny
    meas
    build
    W
    wind1
    wind2
    mapd
    maxv
end
N = nx*ny;
mapsize = 3/meas;   %尺度計算に使う
mapdiameter = meas * 100;   %mainのmaptrueと同じ

%% 風設定
windv = round(nx/meas) * (0.075 * wind2);  %wind velocity 風速10で100mを目安
winda = wind1 + mapd;  %1°刻み 方角差は45度OR22.5度

Til = (pi()/180) * winda;  %角度の設定 Tilt
if winda >=360
    winda = rem(winda,360);
end
if winda>=181 && 359>=winda    %東西判定
    windEW = -abs(windv);
elseif winda>=1 && 179>=winda
    windEW = abs(windv);
end
if rem(winda,180) == 0
    windEW = 0;
end
if winda>=271 || 89>=winda    %南北判定
    windSN = abs(windv);
elseif winda>=91 && 269>=winda
    windSN = -abs(windv);
end
if winda == 90 || winda == 270
    windSN = 0;
end


%% 延焼自動化
spread = 3;
for k = 1:spread
    n4 = 1.2;   % 延焼倍率（0.01刻みで適当な定数で調整，卒論再現の正円の場合は0.99）
    nx0 = nx/2; ny0 = ny/2; % 中心
    r = mapsize * k * n4 * (1.1 + 1/k^2) * sqrt(wind2/10);           % 半径
    t2 = -pi:0.01:pi;
%     xv3 = r * sin(t2);  %正円Verのx（卒論）
%     yv3 = -r * cos(t2); %正円Verのy（卒論）
    xv3 = r * cos(t2./4).*sin(t2);    %卵型Verのx
    yv3 = -r * cos(t2) + r/6;         %卵型Verのy
    
    % 回転項
    for i = 1:length(xv3)
        cyc = [cos(Til), -sin(Til);sin(Til),cos(Til)]*[xv3(i) yv3(i)]';
        xv3(i) = cyc(1);
        yv3(i) = cyc(2);
    end
    
    xv3 = 1.0 * mapsize * xv3 + nx0;
    yv3 = 1.0 * mapsize * yv3 + ny0;
    
    [xq,yq] = meshgrid(1:1:nx);
    in2 = inpolygon(xq,yq,xv3,yv3);
    in2 = logical(in2);
    p = nnz(in2) - 1 %範囲内のセル数
    
    figure(1)
    plot(xv3,yv3)
    hold on
    plot(xq(in2),yq(in2),'r+')
    plot(xq(~in2),yq(~in2),'bo')
    plot(nx0,ny0,'m*')
    hold off
    ax = gca;
    ax.YDir = 'reverse';
    xlim([0 nx+1])
    ylim([0 ny+1])
    A = zeros(N,1);
    ori = ny*(nx0-1) + nx0;
    posi = zeros(p,1);
    for i = 1:N
        if in2(i)>0
            A(i) = i;
        end
    end
    adp = A(A~=0);
    posi = adp - ori;    %対象点と原点間の距離
    % uad:上下にどれだけズレているのか
    % uad2:下一桁の数字=>上下判別用
    NT = ones(N,1);
    WF = zeros(N);
    for i = 1:p
        CC = zeros(N);
        if adp(i)/nx==0
            uad = nx0;
            uad2 = nx;
        else
            uad2 = abs(rem(adp(i),nx));
            if uad2>nx0
                uad = abs(rem(adp(i),nx0));
            else
                uad = nx0 - abs(rem(adp(i),nx0));
            end
        end
        CC = spdiags(NT,posi(i),N,N);
        if uad2>nx0 || uad2==0
            % 下半分に位置している場合
            for j = 1:uad
                CC(:,j:ny:N)=0;
            end
        elseif nx0>uad2 && uad2>=1
            % 上半分に位置してる場合
            for j = 0:uad-1
                CC(:,ny-j:ny:N)=0;
            end
        end
        WF = sparse(WF|CC);
    end
    WF = WF-eye(N);
    nnz(WF);    %非ゼロのセル数算出項
    WFS{k} =  sparse(WF);    %配列内部は結果はWFS{1}(1,:)等で指定できる
end
disp("延焼の隣接行列が生成完了しました");

%% 飛び火用隣接行列
n1 = wind2 * 1.2;
x1 = 0; x2 = 1.5; x3 = -x2;
y1 = 0; y2 = 0.5; y3 = 2*y2;
xv = [x1 x2 x1 x3 x1] * mapsize;
yv = [y1 y2 y3 y2 y1] * mapsize;

for i = 1:length(xv)
    cyc = [cos(Til), sin(Til);-sin(Til),cos(Til)]*[xv(i) yv(i)]';
    xv(i) = cyc(1);
    yv(i) = cyc(2);
end
nx0 = nx/2; ny0 = ny/2;
ori = ny*(nx0-1) + nx0;
[xq,yq] = meshgrid(1:1:nx);
xv1 = n1*xv + nx0 + windEW*abs(sin(Til));
yv1 = n1*yv + ny0 + windSN*abs(cos(Til));
in = inpolygon(xq,yq,xv1,yv1);
in = logical(in);
in = sparse(in);
p = nnz(in) %範囲内のセル数
%% 飛び火範囲確認
% 何故か左右が逆に出る
figure(2)
plot(xv1,yv1)
hold on
plot(xq(in),yq(in),'r+')
plot(xq(~in),yq(~in),'bo')
plot(nx0,ny0,'m*')
hold off
ax = gca;
ax.XDir = 'reverse';
ax.YDir = 'reverse';
xlim([0 nx+1])
ylim([0 ny+1])
%% 図形内の行列番号の取出し
A = zeros(N,1);
posi = zeros(p,1);
for i = 1:N
    if in(i)>0
        A(i) = i;
    end
end
adp = A(A~=0);
posi = adp - ori;    %対象点と原点間の距離
%% 隣接行列生成部
% uad:上下にどれだけズレているのか
% uad2:下一桁の数字=>上下判別用
NT = ones(N,1);
WF = zeros(N);
for i = 1:p
    CC = zeros(N);
    if adp(i)/nx==0
        uad = nx0;
        uad2 = nx;
    else
        uad2 = abs(rem(adp(i),nx));
        if uad2>nx0
            uad = abs(rem(adp(i),nx0));
        else
            uad = nx0 - abs(rem(adp(i),nx0));
        end
    end
    CC = spdiags(NT,posi(i),N,N);
    if uad2>nx0 || uad2==0
        % 下半分に位置している場合
        for j = 1:uad
            CC(:,j:ny:N)=0;
        end
    elseif nx0>uad2 && uad2>=1
        % 上半分に位置してる場合
        for j = 0:uad-1
            CC(:,ny-j:ny:N)=0;
        end
    end
    WF = sparse(WF|CC);
end
nnz(WF);
disp("飛び火の隣接行列が生成完了しました");
%% 最終隣接行列　延焼&飛び火
WS = sparse(0); WS2 = sparse(0);
sigmaWS(1) = 68.27; sigmaWS(2) = (95.45-68.27); sigmaWS(3) = (100-95.45);
% 分子は正規分布のσを基準に、分母は新たに影響を受けるグリッド数を基準に設定
for i = 1:spread
%     WS = ((1/i^2) .* WFS{i} + WS - WS2) .* (meas/3);    % i^2
%     WS2 = ((1/(2*(i+1))^2) .* WFS{i}) .* (meas/3);              % (i+1)^2
    WS = (sigmaWS(i)/sigmaWS(1)) .* WFS{i} + WS - WS2;
    if i ~= spread
        WS2 = (sigmaWS(i+1)/sigmaWS(1)) .* WFS{i};
    end
end

% WS = ((1/i^2) + WS - WS2) .* (meas/3);
% WS2 = ((1/(i+1)^2) .* WFS{i}) .* (meas/3);

if build ~= 3
    WF = ((meas/3)/6000).*WF;
elseif build == 3
    WF = 0;
end

FlyTune = 1.5;   % 風一定:1.5　風細分化:1.0
if wind2 >= 6
    WS = sqrt(wind2/10) .* WS;
    WF = sqrt(wind2/10) .* WF * FlyTune;
elseif wind2 < 6 && wind2 > 0
    WS = (wind2/10) .* WS;
    WF = (wind2/10)^2 .* WF * FlyTune;
else
    disp("風速wind2が変!!!!");
end

% WWN = WS*0.01 + WF*2000;   % 風向細分化確認
WWN = WS + WF;   % 自然延焼Nature　セル延焼+飛び火
% WF = 0;     % 延焼設定用
W10 = reshape(W,[N,1]);

% この計算の遅さは仕方がない
% E2 = (W9./sum(W9,2));% Alt-PageRank
% E = W9.*W10;% Weighted Alt-PageRank
E2 = (WWN./sum(WWN,2));
ES = WS .* W10;
EF = WF .* W10;
E = WWN .* W10;                 %完全自然延焼（風在り）
% E2 = (WWW./sum(WWW,2));
% E = WWW.*W10;                 %延焼阻止線設定時（つまり消防隊が機能している時）の自然延焼
E2 = sparse(E2);
ES = sparse(ES);
EF = sparse(EF);
E = sparse(E);
maxW = max(W,[],'all');
if maxW > 1 | maxv~=1
    ES = (maxv*ES/maxW);
    EF = (maxv*EF/maxW);
    E = (maxv*E/maxW);
end
end

