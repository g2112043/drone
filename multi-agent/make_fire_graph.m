function [E,E2] = make_fire_graph(nx,ny,meas,W,wind,wind2,mapd,maxv)
% Make a graph for nx-ny grid with weight generated by gen
% gen(x,y) generates weight at (x,y)
%   high value means high possibility to burn
%   gen must work with matrix arguments,that is x or y possible to choose as
%   a matrix.
% maxv : max probability, 300m尺度で0.04が目安
% meas : map scale, mease=1なら1セル1m
% E : edge matrix : N-N size matrix where N = nx*ny
% eij : (i,j) element of E
% eij > 0 if edge exists from j to i else eij = 0
% W : weight matrix : nx-ny size matrix
arguments
    nx
    ny
    meas
    W
    wind
    wind2
    mapd
    maxv = 1
end
N = nx*ny;
mapsize = 3/meas;   %尺度計算に使う
mapdiameter = meas * 100;   %mainのmaptrueと同じ

%% 風設定
area = meas * 100; %map直径m
mapc = round(area/30);  % map correction マップ補正
windv = (wind2 + mapc) * mapsize;  %wind velocity
winda = wind + mapd;  %wind angle 22.5°刻み
Til = (pi()/8) * winda;  %角度の設定 Tilt
if winda >=16
    winda = rem(winda,16);
end
if winda>=9 && 15>=winda    %東西判定
    windEW = -abs(windv);
elseif winda>=1 && 7>=winda
    windEW = abs(windv);
end
if rem(winda,8) == 0
    windEW = 0;
end
if winda>=13 || 3>=winda    %南北判定
    windSN = abs(windv);
elseif winda>=5 && 11>=winda
    windSN = -abs(windv);
end
if winda == 4 || winda == 12
    windSN = 0;
end

%% 延焼自動化
spread = 4;
for k = 1:spread
    n3 = 1;   %延焼範囲（今はいじってないが、マップ尺度や風によって自動生成できるとなおよい）
    n4 = 0.99;   % 延焼倍率（0.01刻みで適当な定数で調整，卒論再現の正円の場合は0.99）
    nx0 = nx/2; ny0 = ny/2; % 中心
    r = mapsize * k * n4 + 1;           % 半径
    t2 = -pi:0.01:pi;
%     xv3 = r * sin(t2);  %正円Verのx（卒論）
%     yv3 = -r * cos(t2); %正円Verのy（卒論）
    xv3 = r * cos(t2./4).*sin(t2);    %卵型Verのx
    yv3 = -r * cos(t2) + r/8;         %卵型Verのy
    
    % 回転項
    for i = 1:length(xv3)
        cyc = [cos(Til), -sin(Til);sin(Til),cos(Til)]*[xv3(i) yv3(i)]';
        xv3(i) = cyc(1);
        yv3(i) = cyc(2);
    end
    
    xv3 = 1.0 * n3 * xv3 + nx0;
    yv3 = 1.0 * n3 * yv3 + ny0;
    
    [xq,yq] = meshgrid(1:1:nx);
    in2 = inpolygon(xq,yq,xv3,yv3);
    in2 = logical(in2);
    p = nnz(in2) - 1 %範囲内のセル数
    
    figure(1)
    plot(xv3,yv3)
    hold on
    plot(xq(in2),yq(in2),'r+')
    plot(xq(~in2),yq(~in2),'bo')
    plot(nx0,ny0,'m*')
    hold off
    ax = gca;
    ax.YDir = 'reverse';
    xlim([0 nx+1])
    ylim([0 ny+1])
    A = zeros(N,1);
    ori = ny*(nx0-1) + nx0;
    posi = zeros(p,1);
    for i = 1:N
        if in2(i)>0
            A(i) = i;
        end
    end
    adp = A(A~=0);
    posi = adp - ori;    %対象点と原点間の距離
    % uad:上下にどれだけズレているのか
    % uad2:下一桁の数字=>上下判別用
    NT = ones(N,1);
    WF = zeros(N);
    for i = 1:p
        CC = zeros(N);
        if adp(i)/nx==0
            uad = nx0;
            uad2 = nx;
        else
            uad2 = abs(rem(adp(i),nx));
            if uad2>nx0
                uad = abs(rem(adp(i),nx0));
            else
                uad = nx0 - abs(rem(adp(i),nx0));
            end
        end
        CC = spdiags(NT,posi(i),N,N);
        if uad2>nx0 || uad2==0
            % 下半分に位置している場合
            for j = 1:uad
                CC(:,j:ny:N)=0;
            end
        elseif nx0>uad2 && uad2>=1
            % 上半分に位置してる場合
            for j = 0:uad-1
                CC(:,ny-j:ny:N)=0;
            end
        end
        WF = sparse(WF|CC);
    end
    WF = WF-eye(N);
    nnz(WF);    %非ゼロのセル数算出項
    WFS{k} =  sparse(WF);    %配列内部は結果はWFS{1}(1,:)等で指定できる
end
disp("延焼の隣接行列が生成完了しました");

%% 飛び火用隣接行列
n1 = wind2;
x1 = 0; x2 = 1.5; x3 = -x2;
y1 = 0; y2 = 0.5; y3 = 2*y2;
xv = [x1 x2 x1 x3 x1] * mapsize;
yv = [y1 y2 y3 y2 y1] * mapsize;

for i = 1:length(xv)
    cyc = [cos(Til), sin(Til);-sin(Til),cos(Til)]*[xv(i) yv(i)]';
    xv(i) = cyc(1);
    yv(i) = cyc(2);
end
nx0 = nx/2; ny0 = ny/2;
ori = ny*(nx0-1) + nx0;
[xq,yq] = meshgrid(1:1:nx);
xv1 = n1*xv + nx0 + windEW*abs(sin(Til));
yv1 = n1*yv + ny0 + windSN*abs(cos(Til));
in = inpolygon(xq,yq,xv1,yv1);
in = logical(in);
in = sparse(in);
p = nnz(in) %範囲内のセル数
%% 飛び火範囲確認
% 何故か左右が逆に出る
figure(2)
plot(xv1,yv1)
hold on
plot(xq(in),yq(in),'r+')
plot(xq(~in),yq(~in),'bo')
plot(nx0,ny0,'m*')
hold off
ax = gca;
ax.XDir = 'reverse';
ax.YDir = 'reverse';
xlim([0 nx+1])
ylim([0 ny+1])
%% 図形内の行列番号の取出し
A = zeros(N,1);
posi = zeros(p,1);
for i = 1:N
    if in(i)>0
        A(i) = i;
    end
end
adp = A(A~=0);
posi = adp - ori;    %対象点と原点間の距離
%% 隣接行列生成部
% uad:上下にどれだけズレているのか
% uad2:下一桁の数字=>上下判別用
NT = ones(N,1);
WF = zeros(N);
for i = 1:p
    CC = zeros(N);
    if adp(i)/nx==0
        uad = nx0;
        uad2 = nx;
    else
        uad2 = abs(rem(adp(i),nx));
        if uad2>nx0
            uad = abs(rem(adp(i),nx0));
        else
            uad = nx0 - abs(rem(adp(i),nx0));
        end
    end
    CC = spdiags(NT,posi(i),N,N);
    if uad2>nx0 || uad2==0
        % 下半分に位置している場合
        for j = 1:uad
            CC(:,j:ny:N)=0;
        end
    elseif nx0>uad2 && uad2>=1
        % 上半分に位置してる場合
        for j = 0:uad-1
            CC(:,ny-j:ny:N)=0;
        end
    end
    WF = sparse(WF|CC);
end
nnz(WF);
disp("飛び火の隣接行列が生成完了しました");
%% 最終隣接行列　延焼&飛び火
WS = sparse(0); WS2 = sparse(0);
for i = 1:spread
    WS = ((1/i^2) .* WFS{i} + WS - WS2) .* (meas/3);
    WS2 = ((1/(i+1)^2) .* WFS{i}) .* (meas/3);
end

WF = ((meas/3)/6000).*WF;

% WW = W9 + W17_2;          %2セル延焼
% WWW = W9 + W17_2 + WF;    %2セル延焼+飛び火
% WWN = W9 + WF;   %自然延焼Nature　4セル延焼+飛び火
% WWNc = W9 + W17_2 + W21_3 + W25_4;       %無風時自然延焼Nature　4セル延焼

WW = WS;         %セル延焼のみ
WWN = WS + WF;   %自然延焼Nature　セル延焼+飛び火
W10 = reshape(W,[N,1]);

% この計算の遅さは仕方がない
% E2 = (W9./sum(W9,2));% Alt-PageRank
% E = W9.*W10;% Weighted Alt-PageRank
% E2 = (WW./sum(WW,2));
% E = WW.*W10;                  %延焼阻止線設定時（飛び火無し）
E2 = (WWN./sum(WWN,2));
E = WWN.*W10;                 %完全自然延焼（風在り）
% E2 = (WWW./sum(WWW,2));
% E = WWW.*W10;                 %延焼阻止線設定時（つまり消防隊が機能している時）の自然延焼
E2 = sparse(E2);
E = sparse(E);
maxW = max(W,[],'all');
if maxW > 1 | maxv~=1
    E = (maxv*E/maxW);
end
end

