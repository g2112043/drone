function W = gen_grid_weight(obj,shape_file,flag,opts)
% Make a graph for nx-ny grid with weight generated by gen
% W(x,y) generates weight at (x,y)
%   high value means high possibility to burn
%   gen must work with matrix arguments,that is x or y possible to choose as
%   a matrix.
% model area start from 'start_point' to 'start_point'+'map_size'
% maxv : max probability, 300m尺度で0.04が目安
% map_scale : map scale, map_scale=dなら1セルd m
% E : edge matrix : N-N size matrix where N = nx*ny
% eij : (i,j) element of E
% eij > 0 if edge exists from j to i else eij = 0
% W : weight matrix : nx-ny size matrix
arguments
  obj
  shape_file
  flag
  opts = [];
end
if isempty(opts)
  opts.start_point = [6000,500]; % [x0,y0] position in shape_file data [km]
  opts.map_size = [300,300]; % [x,y] size [km]
  opts.data_type = "geo";
  opts.north_dir = 0;
end

% shape read version
S = shaperead(shape_file);
disp("shape file loaded ");
x = [S.X];
y = [S.Y];
xm = min(x);
ym = min(y);
if flag.debug
  figure(99);
  plot(polyshape(x,y));
  xlim([xm,xm+1500]);
  ylim([ym,ym+700]);
  daspect([1 1 1]);
end
switch opts.data_type
  case "geo"
    % 経度(横・x軸方向) 1㎞ = 0.010966404715491394度
    % 緯度(縦・y軸方向) 1㎞ = 0.0090133729745762度
    tx = 10.966404715491394; % S.X [°] => S.X/tx [m]
    ty = 9.0133729745762;
  case "km"
    tx = 1000; % S.X [km] => S.X/tx [m]
    ty = 1000;
  case "m"
    tx = 1;
    ty = 1; 
end
cn = cos(-opts.north_dir);
sn = sin(-opts.north_dir);
ex = [cn;sn];
ey = [-sn;cn];
O = (opts.start_point.*[tx,ty])';
minXids = cellfun(@(x,y) min(ex'*[x-xm;y-ym]),{S.X},{S.Y}) >= ex'*O;
minYids = cellfun(@(x,y) min(ey'*[x-xm;y-ym]),{S.X},{S.Y}) >= ey'*O;
maxXids = cellfun(@(x,y) max(ex'*[x-xm;y-ym]),{S.X},{S.Y}) <= ex'*O + opts.map_size(1)*tx;
maxYids = cellfun(@(x,y) max(ey'*[x-xm;y-ym]),{S.X},{S.Y}) <= ey'*O + opts.map_size(2)*ty;
S = S(minXids & minYids & maxXids & maxYids);
x = [S.X];
y = [S.Y];
xm = xm + opts.start_point(1)*tx;
ym = ym + opts.start_point(2)*ty;
if flag.debug
  figure(98);
  plot(polyshape(x-xm,y-ym));
  daspect([1 1 1]);
  xlim([0,max([S.X])-xm]);
  ylim([0,max([S.Y])-ym]);
end
% 建物誤認識の解決策
% 同一値を探索し合体する
% [1 2 3 NaN],[3 4 NaN] => [1 2 3 4 NaN]
% ここではデータ群の頭としっぽが繋がるデータを探査
sx = {S.X};
sx = cellfun(@(x) x(1),sx);

clear a b zero
zero = 0;
for i = 1:length(S)
    lenSiX = length(S(i).X);
    deld = 0;
    for j = 1:lenSiX-1
        if length(find(S(i).X(j) == x)) >= 2 && S(i).X(1) ~= S(i).X(lenSiX-1)
            %x中に同じデータが2つある && 同一データ群S(n).X内ではない
            %上記の条件を満たす=データの統合が必要なデータ群
            deld = deld + 1;
            if deld >= 2    %Map範囲縁の建物の削除（不完全）
                zero = zero + 1;
                a(zero) = i;    %(1,...,NaN)が他と結合できるするデータ群ナンバーS(i).Xで参照可能
                b(zero) = j;    %接続先の最終項（[a b ... z NaN]のz）
            end
        end
    end
end

point = zero;  %fusion pointがいくつあるか

if  point ~= 0
    % 改良部分 合体項
    % ここでは探査結果a,bを用いてデータ群を結合
    % このとき余ったほうは[0 NaN]にひとまず置換
    for i = 1:length(a)
        for j = 1:length(b)
            if S(a(i)).X(end-1) == S(a(j)).X(1) && i ~= j
                A = S(a(i)).X;
                A(:,end-1:end) = [];
                S(a(j)).X = [A S(a(j)).X];  %x成分のデータ接続
                B = S(a(i)).Y;
                B(:,end-1:end) = [];
                S(a(j)).Y = [B S(a(j)).Y];  %y成分のデータ接続
                S(a(i)).X = zeros(1,2); %ここから下で重複する部分を[0 NaN]に置換
                S(a(i)).Y = zeros(1,2);
                S(a(i)).X(1) = xm;   % 後で引いた時に0になるように0ではなくxmに
                S(a(i)).Y(1) = ym;
                S(a(i)).X(end) =NaN;
                S(a(i)).Y(end) =NaN;
            end
        end
    end

    % 改良部分 削除項
    % S(n).X = [0 NaN]の部分を削除
    num = 0;    %Sの中で消されたデータの数
    for i = 1:length(a)
        if S(a(i)).X(1) == xm && length(S(a(i)).X) == 2
            % S(a(i)).X = [];
            % S(a(i)).Y = [];
            S(a(i)) = [];
            num = num + 1;
        end
    end

else
    disp("破損したGISデータは存在しませんでした")
end


% 範囲調整したマップの出力項
x = (cn*([S.X]-xm)+sn*([S.Y]-ym))/tx;
y = (cn*([S.Y]-ym)-sn*([S.X]-xm))/ty;
 
% wooden_flaが1で木造、0で非木造と判定
if isfield(S,'wooden_fla')
  IDS = [S.wooden_fla]==0;
  xx = (cn*(S(IDS).X-xm)+sn*(S(IDS).Y-ym))/tx;
  yy = (cn*(S(IDS).Y-ym)-sn*(S(IDS).X-xm))/ty;
end

% 建物のラベリング
%label = [cellfun(@min,{S.X})*1000/tx;cellfun(@min,{S.Y})*1000/ty;1:length(S)]';

[xq,yq] = meshgrid(1:obj.map_scale:obj.nx*obj.map_scale,1:obj.map_scale:obj.ny*obj.map_scale);
in = inpolygon(xq,yq,x,y);
in = logical(in);
if exist('xx','var')
  in2 = inpolygon(xq,yq,xx,yy);
  in2 = logical(in2);
  W = sparse(in - in2*(4/5));
else
  W = double(sparse(in));
end
if flag.debug
  figure(100);
  plot(polyshape(x,y));
  daspect([1 1 1]);
  xlim([0,500]);
  ylim([0,500]);  
end
if flag.debug
  figure(101);
  surf(xq,yq,W);
  legend("x","y","z");
  view(2);daspect([1 1 1]);
  disp("complete generating W");
end

%% W の正規化
maxW = max(W,[],'all');
if maxW > 1 || obj.maxv~=1
  W = (obj.maxv*W/maxW);
end
end
