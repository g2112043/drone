function W = gen_grid_weight(obj,opts)
% Make a graph for nx-ny grid with weight generated by gen
% W(x,y) generates weight at (x,y)
%   high value means high possibility to burn
%   gen must work with matrix arguments,that is x or y possible to choose as
%   a matrix.
% model area start from 'start_point' to 'start_point'+'map_size'
% maxv : max probability, 300m尺度で0.04が目安
% map_scale : map scale, map_scale=dなら1セルd m
% E : edge matrix : N-N size matrix where N = nx*ny
% eij : (i,j) element of E
% eij > 0 if edge exists from j to i else eij = 0
% W : weight matrix : nx-ny size matrix
arguments
  obj
  opts = [];
end
if isempty(opts)
  opts.start_point = [6000,500]; % [x0,y0] position in shape_data data [km]
  opts.map_size = [300,300]; % [x,y] size [km]
  opts.data_type = "geo";
  opts.north_dir = 0;
end

% shape read version
x = [obj.S.X];
y = [obj.S.Y];
xm = min(x);
ym = min(y);
if obj.flag.debug
  figure(99);
  plot(polyshape(x,y));
  xlim([xm,max(x)]);
  ylim([ym,max(y)]);
  daspect([1 1 1]);
end
switch opts.data_type
  case "geo"
    % 経度(横・x軸方向) 1㎞ = 0.010966404715491394度
    % 緯度(縦・y軸方向) 1㎞ = 0.0090133729745762度
    tx = 10.966404715491394; % obj.S.X [°] => obj.S.X/tx [m]
    ty = 9.0133729745762;
  case "km"
    tx = 1000; % obj.S.X [km] => obj.S.X/tx [m]
    ty = 1000;
  case "m"
    tx = 1;
    ty = 1; 
end
cn = cos(-opts.north_dir);
sn = sin(-opts.north_dir);
ex = [cn;sn];
ey = [-sn;cn];
O = (opts.start_point.*[tx,ty])';
minXids = cellfun(@(x,y) min(ex'*[x-xm;y-ym]),{obj.S.X},{obj.S.Y}) >= ex'*O;
minYids = cellfun(@(x,y) min(ey'*[x-xm;y-ym]),{obj.S.X},{obj.S.Y}) >= ey'*O;
maxXids = cellfun(@(x,y) max(ex'*[x-xm;y-ym]),{obj.S.X},{obj.S.Y}) <= ex'*O + opts.map_size(1)*tx;
maxYids = cellfun(@(x,y) max(ey'*[x-xm;y-ym]),{obj.S.X},{obj.S.Y}) <= ey'*O + opts.map_size(2)*ty;
obj.S = obj.S(minXids & minYids & maxXids & maxYids);
x = [obj.S.X];
y = [obj.S.Y];
xm = xm + opts.start_point(1)*tx;
ym = ym + opts.start_point(2)*ty;
if obj.flag.debug
  figure(98);
  plot(polyshape(x-xm,y-ym));
  daspect([1 1 1]);
  xlim([0,max([obj.S.X])-xm]);
  ylim([0,max([obj.S.Y])-ym]);
end
% 建物誤認識の解決策
% 同一値を探索し合体する
% [1 2 3 NaN],[3 4 NaN] => [1 2 3 4 NaN]
% ここではデータ群の頭としっぽが繋がるデータを探査
sx = {obj.S.X};
sx = cellfun(@(x) x(1),sx);

clear a b zero
zero = 0;
for i = 1:length(obj.S)
    lenobj.SiX = length(obj.S(i).X);
    deld = 0;
    for j = 1:lenobj.SiX-1
        if length(find(obj.S(i).X(j) == x)) >= 2 && obj.S(i).X(1) ~= obj.S(i).X(lenobj.SiX-1)
            %x中に同じデータが2つある && 同一データ群obj.S(n).X内ではない
            %上記の条件を満たす=データの統合が必要なデータ群
            deld = deld + 1;
            if deld >= 2    %Map範囲縁の建物の削除（不完全）
                zero = zero + 1;
                a(zero) = i;    %(1,...,NaN)が他と結合できるするデータ群ナンバーobj.S(i).Xで参照可能
                b(zero) = j;    %接続先の最終項（[a b ... z NaN]のz）
            end
        end
    end
end

point = zero;  %fusion pointがいくつあるか

if  point ~= 0
    % 改良部分 合体項
    % ここでは探査結果a,bを用いてデータ群を結合
    % このとき余ったほうは[0 NaN]にひとまず置換
    for i = 1:length(a)
        for j = 1:length(b)
            if obj.S(a(i)).X(end-1) == obj.S(a(j)).X(1) && i ~= j
                A = obj.S(a(i)).X;
                A(:,end-1:end) = [];
                obj.S(a(j)).X = [A obj.S(a(j)).X];  %x成分のデータ接続
                B = obj.S(a(i)).Y;
                B(:,end-1:end) = [];
                obj.S(a(j)).Y = [B obj.S(a(j)).Y];  %y成分のデータ接続
                obj.S(a(i)).X = zeros(1,2); %ここから下で重複する部分を[0 NaN]に置換
                obj.S(a(i)).Y = zeros(1,2);
                obj.S(a(i)).X(1) = xm;   % 後で引いた時に0になるように0ではなくxmに
                obj.S(a(i)).Y(1) = ym;
                obj.S(a(i)).X(end) =NaN;
                obj.S(a(i)).Y(end) =NaN;
            end
        end
    end

    % 改良部分 削除項
    % obj.S(n).X = [0 NaN]の部分を削除
    num = 0;    %obj.Sの中で消されたデータの数
    % for i = 1:length(a)
    %   i
    %   if i == length(a)
    %     i
    %   end
    %     if obj.S(a(i)).X(1) == xm && length(obj.S(a(i)).X) == 2
    %         % obj.S(a(i)).X = [];
    %         % obj.S(a(i)).Y = [];
    %         obj.S(a(i)) = [];
    %         num = num + 1;
    %     end
    % end

else
    disp("破損したGIobj.Sデータは存在しませんでした")
end


% 範囲調整したマップの出力項
x = (cn*([obj.S.X]-xm)+sn*([obj.S.Y]-ym))/tx;
y = (cn*([obj.S.Y]-ym)-sn*([obj.S.X]-xm))/ty;
 
% wooden_flaが1で木造、0で非木造と判定
if isfield(obj.S,'wooden_fla')
  IDobj.S = [obj.S.wooden_fla]==0;
  xx = (cn*(obj.S(IDobj.S).X-xm)+sn*(obj.S(IDobj.S).Y-ym))/tx;
  yy = (cn*(obj.S(IDobj.S).Y-ym)-sn*(obj.S(IDobj.S).X-xm))/ty;
end

% 建物のラベリング
%label = [cellfun(@min,{obj.S.X})*1000/tx;cellfun(@min,{obj.S.Y})*1000/ty;1:length(obj.S)]';

[xq,yq] = meshgrid(1:obj.map_scale:obj.nx*obj.map_scale,1:obj.map_scale:obj.ny*obj.map_scale);
in = inpolygon(xq,yq,x,y);
in = logical(in);
if exist('xx','var')
  in2 = inpolygon(xq,yq,xx,yy);
  in2 = logical(in2);
  W = sparse(in - in2*(4/5));
else
  W = double(sparse(in));
end
if obj.flag.debug
  figure(100);
  plot(polyshape(x,y));
  daspect([1 1 1]);
  xlim([0,500]);
  ylim([0,500]);  
end
if obj.flag.debug
  figure(101);
  surf(xq,yq,W);
  legend("x","y","z");
  view(2);daspect([1 1 1]);
  disp("complete generating W");
end

%% W の正規化
maxW = max(W,[],'all');
if maxW > 1 || obj.maxv~=1
  W = (obj.maxv*W/maxW);
end
end
