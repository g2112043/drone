function W = gen_grid_weight(obj,shape_file,flag,opts)
% Make a graph for nx-ny grid with weight generated by gen
% W(x,y) generates weight at (x,y)
%   high value means high possibility to burn
%   gen must work with matrix arguments,that is x or y possible to choose as
%   a matrix.
% model area start from 'start_point' to 'start_point'+'map_size'
% maxv : max probability, 300m尺度で0.04が目安
% map_scale : map scale, map_scale=dなら1セルd m
% E : edge matrix : N-N size matrix where N = nx*ny
% eij : (i,j) element of E
% eij > 0 if edge exists from j to i else eij = 0
% W : weight matrix : nx-ny size matrix
arguments
  obj
  shape_file
  flag
  opts = [];
end
if isempty(opts)
  opts.start_point = [6,0.5]; % [x0,y0] position in shape_file data [km]
  opts.map_size = [0.3,0.3]; % [x,y] size [km]
  opts.data_type = "geo";
end

% shape read version
S = shaperead(shape_file);
disp("shape file loaded ");
x = [S.X];
y = [S.Y];
xm = min(x);
ym = min(y);
switch opts.data_type
  case "geo"
    % 経度(横・x軸方向) 1㎞ = 0.010966404715491394度
    % 緯度(縦・y軸方向) 1㎞ = 0.0090133729745762度
    tx = 0.010966404715491394; % S.X [°] => S.X/tx [km]
    ty = 0.0090133729745762;
  case "km"
    tx = 1;
    ty = 1;
  case "m"
    tx = 1000;
    ty = 1000; % S.X [m] => S.X/tx [km]
end
marginx = 0.015*tx;
marginy = 0.015*ty;
Amin = [xm,ym] + opts.start_point.*[tx,ty];
Amax = Amin + opts.map_size.*[tx,ty];
minXids = cellfun(@min,{S.X}) >= Amin(1) - marginx;
minYids = cellfun(@min,{S.Y}) >= Amin(2) - marginy;
maxXids = cellfun(@max,{S.X}) <= Amax(1) + marginx;
maxYids = cellfun(@max,{S.Y}) <= Amax(2) + marginy;
S = S(minXids & minYids & maxXids & maxYids);
mapshow(S)
x = [S.X];
y = [S.Y];
xm = min(x);
ym = min(y);

% wooden_flaが1で木造、0で非木造と判定
if isfield(S,'wooden_fla')
  IDS = [S.wooden_fla]==0;
  xx = S(IDS).X;
  yy = S(IDS).Y;
end

% 改良部分 探索項
% 建物誤認識の解決策
% 同一値を探索し合体する
% [1 2 3 NaN],[3 4 NaN] => [1 2 3 4 NaN]
% ここではデータ群の頭としっぽが繋がるデータを探査
clear a b zero
zero = 0;
for i = 1:length(S)
    lenSiX = length(S(i).X);
    deld = 0;
    for j = 1:lenSiX-1
        if length(find(S(i).X(j) == x)) >= 2 && S(i).X(1) ~= S(i).X(lenSiX-1)
            %x中に同じデータが2つある && 同一データ群S(n).X内ではない
            %上記の条件を満たす=データの統合が必要なデータ群
            deld = deld + 1;
            if deld >= 2    %Map範囲縁の建物の削除（不完全）
                zero = zero + 1;
                a(zero) = i;    %(1,...,NaN)が他と結合できるするデータ群ナンバーS(i).Xで参照可能
                b(zero) = j;    %接続先の最終項（[a b ... z NaN]のz）
            end
        end
    end
end

point = zero;  %fusion pointがいくつあるか

if  point ~= 0
    % 改良部分 合体項
    % ここでは探査結果a,bを用いてデータ群を結合
    % このとき余ったほうは[0 NaN]にひとまず置換
    for i = 1:length(a)
        for j = 1:length(b)
            if S(a(i)).X(end-1) == S(a(j)).X(1) && i ~= j
                A = S(a(i)).X;
                A(:,end-1:end) = [];
                S(a(j)).X = [A S(a(j)).X];  %x成分のデータ接続
                B = S(a(i)).Y;
                B(:,end-1:end) = [];
                S(a(j)).Y = [B S(a(j)).Y];  %y成分のデータ接続
                S(a(i)).X = zeros(1,2); %ここから下で重複する部分を[0 NaN]に置換
                S(a(i)).Y = zeros(1,2);
                S(a(i)).X(1) = xm;   % 後で引いた時に0になるように0ではなくxmに
                S(a(i)).Y(1) = ym;
                S(a(i)).X(end) =NaN;
                S(a(i)).Y(end) =NaN;
            end
        end
    end

    % 改良部分 削除項
    % S(n).X = [0 NaN]の部分を削除
    num = 0;    %Sの中で消されたデータの数
    for i = 1:length(a)
        if S(a(i)).X(1) == xm && length(S(a(i)).X) == 2
            S(a(i)).X = [];
            S(a(i)).Y = [];
            num = num + 1;
        end
    end

else
    disp("破損したGISデータは存在しませんでした")
end


% 範囲調整したマップの出力項
x = [S.X] - xm;
y = [S.Y] - ym;

% 行列生成 範囲絞り機能付きVer
% NaNは区切りを意味する。値が入ってない
x = (1000 * x)/tx;   % 経度のm変換
y = (1000 * y)/ty;  % 緯度のm変換

%disp("マップのベクトル化が完了しました");

% 建物のラベリング
%label = [cellfun(@min,{S.X})*1000/tx;cellfun(@min,{S.Y})*1000/ty;1:length(S)]';

[xq,yq] = meshgrid(1:obj.map_scale:obj.nx*obj.map_scale);
in = inpolygon(xq,yq,x,y);
in = logical(in);
if exist('xx','var')
  xx = xx - xm;
  yy = yy - ym;
  xx = (1000 * xx)/tx;   % のm変換
  yy = (1000 * yy)/ty;  % 緯度のm変換
  in2 = inpolygon(xq,yq,xx,yy);
  in2 = logical(in2);
  W = sparse(in - in2*(4/5));
else
  W = double(sparse(in));
end
if flag.debug
  figure(100);
  plot(polyshape(x-xm,y-ym));
  daspect([1 1 1]);
end
if flag.debug
figure(101);
  [xq,yq] = meshgrid(1:1:obj.nx);
surf(xq,yq,W);
legend("x","y","z");
view(2);daspect([1 1 1]);
disp("complete generating W");
end

%% W の正規化
maxW = max(W,[],'all');
if maxW > 1 || obj.maxv~=1
  W = (obj.maxv*W/maxW);
end
end
