%tanhと線形で近似tanhをいくつか組み合わせてもいいかも
%最小のalpに対して入力の変化が耐えられるようにするこれができれば初期値のalpの値を小さくできるかも
%ddxとdddxの項は近似しなくてもいいかも
%最適化でパラメータ調整するといいかも．そうすればtanhをいくつか組み合わせる方法でもパラメータ調整簡単そう
clear 
% e= -1:0.001:1;
% e = -0.35:0.001:0.35;
e= -0.1:0.001:0.1;
alp = [0.692307692307692;0.750000000000000;0.818181818181818;0.900000000000000];%初期値0.9有限整定のべき乗
k = [82.3694335484227,132.127723488091,64.7874537390378,13.9398476471445];%FBゲイン

g = [1 1 1 1];%元のゲインの倍率調整
a = [1 1 1 1];%曲がり具合のきつさ
%近似普通誤差0.1x
g = [0.105, 0.08, 0.055, 0.028];
a = [20, 18, 16, 15];
kg01= k.*g;
    % g(1) = 0.1;
    % a(1)=20;
    % g(2) = 0.08;
    % a(2)=18;
    % g(3) = 0.055;
    % a(3)=16;
    % g(4) = 0.028;
    % a(4)=15;
%近似Fbとの入力誤差が一番大きくなるところ[0.3, 0.3160, 0.3320, 0.3490]での近似x
g = [0.135, 0.105, 0.075, 0.035];
a = [9.5, 9, 9.5, 9.5];
kg= k.*g;
    % g(1) = 0.135;
    % a(1)=9.5;
    % g(2) = 0.105;
    % a(2)=9;
    % g(3) = 0.075;
    % a(3)=9.5;
    % g(4) = 0.035;
    % a(4)=9.5;
%近似強めより近くで近似
% g(1) = 0.1;
% a(1)=40;
titlex=["x","dx","ddx","dddx"];
for i = 1:4
    ufb(i,:)= -k(i)*e;
    u(i,:)= -k(i)*sign(e).*abs(e).^alp(i);
%     u2= -k(2)*sign(t).^alp(2).*abs(t);
%     u3= -k(3)*sign(t).^alp(3).*abs(t);
%     u4= -k(4)*sign(t).^alp(4).*abs(t);
    
    utanh(i,:)=-k(i)*g(i)*tanh(a(i)*e)-k(i)*e;
%     utanh2=-k(2)*tanh(a(2)*t)-k(2)*t;
%     utanh3=-k(3)*tanh(a(3)*t)-k(3)*t;
%     utanh4=-k(4)*tanh(a(4)*t)-k(4)*t;
% n=10;
%     up(i,:) = polyfit(e,u(i,:),n);
%     up2(i,:) = polyval(up(i,:),e2);

sigma(i,:) =abs( u(i,:)-ufb(i,:));
smax = max(sigma(i,:))
imax = find(sigma(i,:)==smax);
e(1,imax)

sigma2(i,:) = -utanh(i,:)+u(i,:);
smax2 = max(sigma2(i,:))
imax2 = find(sigma2(i,:)==smax2);
e(1,imax2)
    figure(3*i-2)  
        plot(e,u(i,:),e,utanh(i,:),e,ufb(i,:))
        legend("FT","tanh","FB")
        grid on
        title(titlex(i))
    
%     figure(3*i-1)
%         plot(e,sigma(i,:),e(1,imax),sigma(i,imax),'*')
%         grid on

    figure(3*i)
        plot(e,sigma2(i,:))%,e(1,imax2))%sigma2(i,imax2),'*')
        grid on
        title(titlex(i)+"元の入力との差")
end
%%
%元の入力と近似の入力の差を取り二乗しそれを積分する
e= -0.1:0.001:0.1;
alp = [0.692307692307692;0.750000000000000;0.818181818181818;0.900000000000000];%初期値0.9有限整定のべき乗
k = [82.3694335484227,132.127723488091,64.7874537390378,13.9398476471445];%FBゲイン

syms f1 f2 a1 a2 e
utanh = -f1*tanh(a1*e)-f2*tanh(a2*e)-k(1)*e;
u = -k(1)*sign(e)*abs(e)^alp(1);
sigma = (u - utanh)^2;
insigma = int(sigma,e,[0,1]);
%% フーリエ変換してみよう->だめそうtanhで頑張る
syms k e alp w
f = -k*sign(e)*abs(e)^alp;
f_f = fourier(f);
ff = matlabFunction(f_f,"Vars",{k,e,alp,w});

e= -0.10:0.001:0.10;
alp = [0.692307692307692;0.750000000000000;0.818181818181818;0.900000000000000];
a = [3,4,4,4];
k = [82.3694335484227,132.127723488091,64.7874537390378,13.9398476471445];

ufri1 = ff(k(1),e,alp(1),1);

%     up2(i) = polyval(e,up(i));
%     plot(e,up2(2))
